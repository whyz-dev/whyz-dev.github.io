<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>whyz Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whyz-dev.github.io/"/>
  <updated>2024-10-31T10:43:11.808Z</updated>
  <id>https://whyz-dev.github.io/</id>
  
  <author>
    <name>whyz (GangJun Jo)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Dacon] 2024 생명연구자원 AI활용 경진대회 후기</title>
    <link href="https://whyz-dev.github.io/2024/10/31/Dacon-2024-%EC%83%9D%EB%AA%85%EC%97%B0%EA%B5%AC%EC%9E%90%EC%9B%90-AI%ED%99%9C%EC%9A%A9-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C-%ED%9B%84%EA%B8%B0/"/>
    <id>https://whyz-dev.github.io/2024/10/31/Dacon-2024-생명연구자원-AI활용-경진대회-후기/</id>
    <published>2024-10-31T08:37:48.000Z</published>
    <updated>2024-10-31T10:43:11.808Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p> 몇 달 전에 정형 데이터 머신러닝을 공부하기 위해서 캐글에 있는 <strong>Housing Prices Competition for Kaggle Learn Users</strong>라는 모의 대회를 참여했었다. 마침 공부하기에 좋은 코드가 있었고,  이를 적용해볼만한 정형 데이터 대회가 없을까 하다가 발견한 대회가 Dacon의 <strong>2024 생명연구자원 AI활용 경진대회</strong>였다.</p><p> 데이터를 처음 봤을 때 이게 무슨 의미인지 한참 고민했다. 알 수 없는 용어들과 무수한 WT들.. 덕분에 몇 일 동안은 chatGPT를 끼고 도메인 지식을 얻으려고 애썼다. 나는 각 열의 이름이 유전자의 이름을 나타낸다는 것과 WT를 제외한 데이터는 SNV 형태의 데이터를 의미한다는 것을 알았다. 변이의 종류(Silent, Missense, Nonsense)로 one-hot encoding하고 이를 단순하게 XGBoost에 넣어 Baseline을 만들었다. </p><p> 이 대회의 평가 산식은 F1 score macro였다. 그리고 초기에 제출했던 내 퍼블릭 스코어는 <strong>0.119</strong>이다. 그 당시 상위권의 스코어가 0.6~0.7이었으니 이정도 상승을 노리려면 모델을 깎기보다 데이터를 더 다듬어 보기로했다. </p><p> 먼저 나는 대회에서 제공하는 데이터가 부족하다는 것을 느꼈다. 그래서 TCGA가 제공하는 MAF 파일을 대회의 입력에 맞게 전처리를 했다. 그리고 변이의 종류에 따라서 암에 주는 영향이 다르다는 도메인 지식을 이용해 암에 더 영향을 많이줄수록 더 많은 점수를 주도록 label encoding을 진행하였다. 또한 모델의 입력 크기가 4300정도였으니 이는 모델에 차원의 저주가 있을 수 있다고 생각했고 PCA를 적용하였다. 이후 스코어는 <strong>0.386</strong>으로 상승했다.</p><p> 이외에도 대회에서 분류하는 데 사용하지 않는 예측 변수 데이터를 other로 분리하여 학습하는데 사용해보았다. 그리고 LightGBM, MLP과 같은 다른 모델을 적용하거나 voting classifier로 ensemble도 해보았으나 정답률 향상이 크지 않았다.</p><p> 따라서 나는 여전히 데이터에서 개선할 부분이 있을 것이라고 생각했고, 예측 class의 불균형 문제를 해결하지 않았음을 깨닫고 SMOTE와 ADASYN을 이용하여 클래스 불균형 문제를 해결했다. 그러면서 스코어는 <strong>0.45</strong>까지 상승했다.</p><p> 이후 나는 데이터를 ICGC와 GTEX 데이터를 추가해보았으나 정답률에 큰 영향이 없음을 알았고, 이제 데이터가 부족한 것은 아니며 모델을 깎을 수도 없으므로 피쳐를 해석하는 부분에서 정답률 개선을 이루어야겠다고 생각했다. 단순 변이 종류를 레이블 인코딩한 것 이외에, 한 유전자에서 일어나는 변이의 개수와 점수의 합, 변이 위치의 최솟값 등을 이용해 스코어를 <strong>0.49</strong>까지 상승시켰다.</p><p> 그리고 나서 한동안 진전이 없었으므로 도메인 지식과 관련된 정보를 다시 공부하고자했다. 때문에 나는 “Misannotated Multi-Nucleotide Variants in Public Cancer<br>Genomics Datasets Lead to Inaccurate Mutation Calls<br>with Significant Implications” 이라는 논문과 “Cancer classification based on multiple dimensions: SNV patterns”를 읽었다. 간단히 요약하면 SNV 데이터는 하나의 아미노산 변이만을 표기하므로 여러개의 변이를 포함하는 MNV 데이터로 변환하면 정답률이 올라갈것이라는 것과, 아미노산이 변이하기 전과 후의 정보로 KNN 클러스터링을 하면 암 종류 분석의 정답률이 높게 나온다는 논문이었다.</p><p> 나는 이를 이용하여 새로운 피쳐를 추가하였고 <strong>0.502</strong>의 스코어를 얻었다. 이를 마지막 제출로 나는 최종 <strong>17등</strong>을 할 수 있었다. 비율로 따지면 상위 **1.8%**의 성적이다. 2년만에 나가본 대회인데, 2년 전이랑은 비교도 안되는 순위로 마무리를 할 수 있었다는 것에 크게 만족하고있다.</p><p> Kaggle에서 Expert를 달자는 목표에 한 발자국 다가갈 수 있어서 정말 기쁘다. 앞으로도 더 좋은 성적을 거둘 수 있도록 연습을 꾸준히 해야겠다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[Dacon] 2024 생명연구자원 AI활용 경진대회 후기&lt;/p&gt;
    
    </summary>
    
      <category term="Dacon" scheme="https://whyz-dev.github.io/categories/Dacon/"/>
    
    
      <category term="review" scheme="https://whyz-dev.github.io/tags/review/"/>
    
      <category term="structured data" scheme="https://whyz-dev.github.io/tags/structured-data/"/>
    
      <category term="bio data" scheme="https://whyz-dev.github.io/tags/bio-data/"/>
    
      <category term="ML" scheme="https://whyz-dev.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 3176 | 도로 네트워크</title>
    <link href="https://whyz-dev.github.io/2019/08/07/BOJ-3176-%EB%8F%84%EB%A1%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"/>
    <id>https://whyz-dev.github.io/2019/08/07/BOJ-3176-도로-네트워크/</id>
    <published>2019-08-07T14:06:00.000Z</published>
    <updated>2022-08-13T19:17:17.398Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/3176">https://www.acmicpc.net/problem/3176</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>sparse table을 이용한 LCA 문제.</p><p>LCA를 구현하고, 다음과 같은 DP 테이블을 만든다.</p><p>maxi[i][j] &#x3D; i의 j번째 조상까지의 도로중 가장 긴 도로의 길이.</p><p>maxi[i][j] &#x3D; max(maxi[parent[i][j - 1]][j - 1], maxi[i][j-1]);</p><p>maxi[i][j] &#x3D; i의 j번째 조상까지의 도로중 가장 짧은 도로의 길이.</p><p>mini[i][j] &#x3D; min(mini[parent[i][j - 1]][j - 1], mini[i][j - 1]);</p><p>이를 잘 이용하여 풀면 된다.</p><p>sparse-table 초기화에 O(NlogN)</p><p>쿼리 실행 중, 두 노드의 높이를 맞추는데 O(logN), 가장 긴&#x2F;짧은 도로를 찾는데 O(logN)이므로,</p><p>쿼리 실행의 시간복잡도는 O(QlogN).</p><p>전체 시간복잡도는 O((Q+N)logN)</p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, depth[<span class="number">110000</span>], mini[<span class="number">110000</span>][<span class="number">20</span>], maxi[<span class="number">110000</span>][<span class="number">20</span>], parent[<span class="number">110000</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;P&gt; G[<span class="number">110000</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">G[a].<span class="built_in">push_back</span>(&#123; b,c &#125;);</span><br><span class="line">G[b].<span class="built_in">push_back</span>(&#123; a,c &#125;);</span><br><span class="line">&#125;</span><br><span class="line">depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">parent[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> now = Q.<span class="built_in">front</span>();</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (P nxt : G[now]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!depth[nxt.first]) &#123;</span><br><span class="line">depth[nxt.first] = depth[now] + <span class="number">1</span>;</span><br><span class="line">mini[nxt.first][<span class="number">0</span>] = nxt.second;</span><br><span class="line">maxi[nxt.first][<span class="number">0</span>] = nxt.second;</span><br><span class="line">parent[nxt.first][<span class="number">0</span>] = now;</span><br><span class="line">Q.<span class="built_in">push</span>(nxt.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">parent[j][i] = parent[parent[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">maxi[j][i] = <span class="built_in">max</span>(maxi[parent[j][i - <span class="number">1</span>]][i - <span class="number">1</span>], maxi[j][i<span class="number">-1</span>]);</span><br><span class="line">mini[j][i] = <span class="built_in">min</span>(mini[parent[j][i - <span class="number">1</span>]][i - <span class="number">1</span>], mini[j][i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> a, b, dismax=<span class="number">0</span>, dismin=<span class="number">1000000</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (depth[a] &lt; depth[b])</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="type">int</span> diff = depth[a] - depth[b];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; diff; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (diff &amp; <span class="number">1</span>) &#123;</span><br><span class="line">dismax = <span class="built_in">max</span>(dismax, maxi[a][i]);</span><br><span class="line">dismin = <span class="built_in">min</span>(dismin, mini[a][i]);</span><br><span class="line">a = parent[a][i];</span><br><span class="line">&#125;</span><br><span class="line">diff /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a != b) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (parent[a][i] != parent[b][i]) &#123;</span><br><span class="line">dismax = <span class="built_in">max</span>(&#123; dismax, maxi[a][i], maxi[b][i] &#125;);</span><br><span class="line">dismin = <span class="built_in">min</span>(&#123; dismin, mini[a][i], mini[b][i] &#125;);</span><br><span class="line">a = parent[a][i], b = parent[b][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dismax = <span class="built_in">max</span>(&#123; dismax, maxi[a][<span class="number">0</span>], maxi[b][<span class="number">0</span>] &#125;);</span><br><span class="line">dismin = <span class="built_in">min</span>(&#123; dismin, mini[a][<span class="number">0</span>], mini[b][<span class="number">0</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dismin &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dismax &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 3176 | 도로 네트워크&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="DP" scheme="https://whyz-dev.github.io/tags/DP/"/>
    
      <category term="LCA" scheme="https://whyz-dev.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 5419 | 북서풍</title>
    <link href="https://whyz-dev.github.io/2019/08/07/BOJ-5419-%EB%B6%81%EC%84%9C%ED%92%8D/"/>
    <id>https://whyz-dev.github.io/2019/08/07/BOJ-5419-북서풍/</id>
    <published>2019-08-07T13:01:09.000Z</published>
    <updated>2022-08-13T19:17:15.706Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/5419">https://www.acmicpc.net/problem/5419</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>임의의 한 섬(a,b)을 기준으로, 그 점과 이어질 수 있는 섬(c,d)들은 모두 a&lt;&#x3D;c와 b&gt;c를 만족해야한다.</p><p>이를 이용하여, y축을 기준으로 오름차순으로 정렬하고, y축이 같은 경우는 x기준으로 내림차순으로 정렬하면, 아무 섬이나 잡아도, 해당 섬 이전에 선택된 섬들은 모두 해당 섬보다 남쪽에 있을 것임이 자명하다.<br>또한 이전에 선택된 섬들 중에, 해당 섬보다 동쪽에 있는 섬들의 개수를 세주면, 해당 섬보다 남쪽에 있으면서 동쪽에 있는 섬들을 모두 선택할 수 있게 된다.</p><p>단, 좌표가 -10^9~10^9이므로, O(N)으로 가능한 X좌표들을 모두 저장해두고, 이분 탐색으로 index 위치를 찾는다. </p><p>섬들의 개수는 세그먼트 트리로 O(logN)만에 구할 수 있으며, 개수 업데이트에 O(logN), 이분 탐색에 O(logN)이므로,</p><p>모든 점 탐색은O(NlogN)만에 가능하다. </p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[<span class="number">400000</span>], num[<span class="number">80000</span>], MAX, T,N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(P a, P b)</span> </span>&#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(P a, P b)</span> </span>&#123; <span class="keyword">return</span> (a.second == b.second) ? (a.first &gt; b.first):(a.second &lt; b.second); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">p += MAX;</span><br><span class="line">tree[p] += v;</span><br><span class="line"><span class="keyword">for</span> (; p /= <span class="number">2</span>; tree[p] = tree[<span class="number">2</span> * p] + tree[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">s += MAX, e += MAX;</span><br><span class="line"><span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line"><span class="keyword">if</span> (s % <span class="number">2</span>)</span><br><span class="line">res += tree[s++];</span><br><span class="line"><span class="keyword">if</span> (e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">res += tree[e--];</span><br><span class="line">s /= <span class="number">2</span>, e /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e == s)</span><br><span class="line">res += tree[s];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">;<span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> size = <span class="number">0</span>, res=<span class="number">0</span>; </span><br><span class="line">vector&lt;P&gt; V;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (MAX = <span class="number">1</span>; MAX &lt; N; MAX *= <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="built_in">sizeof</span>(tree));</span><br><span class="line"><span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">V.<span class="built_in">push_back</span>(&#123; x,y &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(), V.<span class="built_in">end</span>(), cmp1);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!i || num[size] != V[i].first)</span><br><span class="line">num[size++] = V[i].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(), V.<span class="built_in">end</span>(), cmp2);</span><br><span class="line"><span class="keyword">for</span> (P idx : V) &#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = size<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num[m] &gt; idx.first)</span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num[m] &lt; idx.first)</span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l = m;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res += <span class="built_in">sum</span>(l, size);</span><br><span class="line"><span class="built_in">update</span>(l, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 5419 | 북서풍&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="segment-tree" scheme="https://whyz-dev.github.io/tags/segment-tree/"/>
    
      <category term="binary-search" scheme="https://whyz-dev.github.io/tags/binary-search/"/>
    
      <category term="line-sweeping" scheme="https://whyz-dev.github.io/tags/line-sweeping/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 13537 | 수열과 쿼리 1</title>
    <link href="https://whyz-dev.github.io/2019/08/01/BOJ-13537-%EC%88%98%EC%97%B4%EA%B3%BC-%EC%BF%BC%EB%A6%AC-1/"/>
    <id>https://whyz-dev.github.io/2019/08/01/BOJ-13537-수열과-쿼리-1/</id>
    <published>2019-08-01T14:04:48.000Z</published>
    <updated>2024-10-31T09:55:25.213Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/13537">https://www.acmicpc.net/problem/13537</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>수열을 다음과 같은 업데이트 쿼리로 해석한다.</p><p>a b : 위치가 a인 위치를 b로 교체</p><p>그리고 쿼리 (i j k)를 k에 대해 내림차순으로 정렬한다.</p><p>업데이트 쿼리들도 마찬가지로, b에 대해 내림차순으로 정렬한다.</p><p>그리고, k&gt;b를 만족할때, 세그먼트 트리에서 위치가 a인 곳에 1을 업데이트 한다.</p><p>그러면, 트리에서 i부터 j까지의 합이 쿼리 (i j k)에 대한 답변이 된다.</p><p>출력할때도, 쿼리의 입력순으로 정렬해주자. </p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_</span> &#123; ll idx, i, j, k; &#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(_ a, _ b) &#123; <span class="keyword">return</span> a.k &gt; b.k; &#125;</span><br><span class="line">vector&lt;_&gt; query;</span><br><span class="line">vector&lt;pair&lt;ll, ll&gt; &gt;arr, ans;</span><br><span class="line">ll N, MAX, tree[<span class="number">400000</span>], M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll p, ll v)</span> </span>&#123;</span><br><span class="line">p += MAX;</span><br><span class="line">tree[p] = v;</span><br><span class="line"><span class="keyword">for</span> (; p /= <span class="number">2</span>; tree[p] = tree[<span class="number">2</span> * p] + tree[<span class="number">2</span> * p + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll s, ll e)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line">s += MAX, e += MAX;</span><br><span class="line"><span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line"><span class="keyword">if</span> (s % <span class="number">2</span>)</span><br><span class="line">res += tree[s++];</span><br><span class="line"><span class="keyword">if</span> (e % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">res += tree[e--];</span><br><span class="line">e /= <span class="number">2</span>;</span><br><span class="line">s /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s==e)</span><br><span class="line">res += tree[e];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (MAX = <span class="number">1</span>; MAX &lt; N; MAX *= <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">ll tmp;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">arr.<span class="built_in">push_back</span>(&#123; tmp,i &#125;);</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">ll a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">query.<span class="built_in">push_back</span>(&#123; i,a,b,c &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), greater&lt;pair&lt;ll, ll&gt; &gt;() );</span><br><span class="line"><span class="built_in">sort</span>(query.<span class="built_in">begin</span>(), query.<span class="built_in">end</span>());</span><br><span class="line">ll now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> idx : query) &#123;</span><br><span class="line"><span class="keyword">while</span> (now &lt; arr.<span class="built_in">size</span>() &amp;&amp; idx.k &lt; arr[now].first) &#123;</span><br><span class="line"><span class="built_in">update</span>(arr[now].second, <span class="number">1</span>);</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123; idx.idx, <span class="built_in">sum</span>(idx.i,idx.j) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> idx : ans)</span><br><span class="line">cout &lt;&lt; idx.second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 13537 | 수열과 쿼리 1&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="segment_tree" scheme="https://whyz-dev.github.io/tags/segment-tree/"/>
    
      <category term="sort" scheme="https://whyz-dev.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 2436 | 공약수</title>
    <link href="https://whyz-dev.github.io/2019/07/28/BOJ-2436-%EA%B3%B5%EC%95%BD%EC%88%98/"/>
    <id>https://whyz-dev.github.io/2019/07/28/BOJ-2436-공약수/</id>
    <published>2019-07-28T03:10:00.000Z</published>
    <updated>2022-08-13T19:17:19.810Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/2436">https://www.acmicpc.net/problem/2436</a></p><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li>KOI 2011 초등부 2번</li><li>KOI 2011 중등부 1번</li><li>KOI 2011 고등부 1번</li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>유클리드 호제법 (최대공약수 구하기) :<a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95">https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95</a> </p><p>여기서는 두 입력으로 최대공약수와 최소공배수를 준다.</p><p>두 수를 각 a와 b라고 할때, LCM을 다음과 같이 나타낼 수 있다.</p><p>LCM &#x3D; a*b&#x2F;GCD</p><p>이를 정리하면,</p><p>GCD * LCM &#x3D; a*b</p><p>이를 이용하여 시간복잡도 O(sqrt(GCD*LCM)) &#x3D; O(sqrt(a*b))만에 풀 수 있다.</p><p>입력이 1억이니, int 범위 초과에 주의하자. </p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> GCD, LCM, mul, a, b, flag;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a%b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; GCD &gt;&gt; LCM;</span><br><span class="line">mul = GCD * LCM;</span><br><span class="line">a = <span class="number">1</span>; b = LCM;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= mul / i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mul%i || <span class="built_in">gcd</span>(i, mul / i) != GCD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">a = i, b = mul / i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 2436 | 공약수&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="KOI" scheme="https://whyz-dev.github.io/tags/KOI/"/>
    
      <category term="Euclidean-algorithm" scheme="https://whyz-dev.github.io/tags/Euclidean-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 11047 | 동전 0</title>
    <link href="https://whyz-dev.github.io/2019/07/26/BOJ-11047-%EB%8F%99%EC%A0%84-0/"/>
    <id>https://whyz-dev.github.io/2019/07/26/BOJ-11047-동전-0/</id>
    <published>2019-07-26T13:55:16.000Z</published>
    <updated>2022-08-13T19:17:13.484Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/11047">https://www.acmicpc.net/problem/11047</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>문제를 읽어보면, “A_1 &#x3D; 1, i ≥ 2인 경우에 A_i는 A_{i-1}의 배수”라는 조건이 있는데,</p><p>첫번째 조건을 통해, “만들지 못하는 경우는 없다.”를 추측해낼 수 있고,</p><p>두번째 조건을 통해, “tA_{i-1}는 A_i로 대체할 수 있다.”를 추측해낼 수 있다. (t는 임의의 상수)</p><p>가치가 A_i인 동전을 가치가 A_{i-1}동전으로 대체할 수 있으나, </p><p>가치가 A_{i-1}를 여러개 쓰는 것 보다,  가치가 A_i인 큰 동전 하나로 바꾸는게 이득이라는 것을 알 수 있다.</p><p>이렇게 가장 큰 동전부터 사용하여, greedy한 방법으로 정답을 찾을 수 있다.</p><p>시간복잡도는 동전의 개수, 즉 O(N)이다.</p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, cnt, coin[<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">cin &gt;&gt; coin[i];</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (coin[n] &gt; k) &#123;</span><br><span class="line">n--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt += k / coin[n];</span><br><span class="line">k %= coin[n];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 11047 | 동전 0&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="greedy" scheme="https://whyz-dev.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 2294 | 동전 2</title>
    <link href="https://whyz-dev.github.io/2019/07/26/BOJ-2294-%EB%8F%99%EC%A0%84-2/"/>
    <id>https://whyz-dev.github.io/2019/07/26/BOJ-2294-동전-2/</id>
    <published>2019-07-26T13:32:25.000Z</published>
    <updated>2022-08-13T19:17:21.618Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/2294">https://www.acmicpc.net/problem/2294</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p><a href="https://www.acmicpc.net/problem/2293">https://www.acmicpc.net/problem/2293</a>을 풀면 사고를 확장하여 쉽게 풀 수 있다.</p><p>DP[i]를 i번 동전을 만들 수 있는 최소 횟수라고 정의하면,</p><p>DP[i] &#x3D; max(DP[i], DP[ i - coin[j] ] + 1), j &#x3D; 0~n-1 로 정리된다.</p><p>위 점화식을 그대로 적용하면 AC를 받게된다.</p><p>시간복잡도는 동전 1과 같은 O(NM).</p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, dp[<span class="number">10010</span>], coin[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">cin &gt;&gt; coin[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">dp[i] = MAX;</span><br><span class="line"><span class="built_in">sort</span>(coin, coin + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line"><span class="keyword">if</span> (i &gt;= coin[j])</span><br><span class="line">dp[i] = <span class="built_in">min</span>(dp[i - coin[j]]+<span class="number">1</span>, dp[i]);</span><br><span class="line"><span class="keyword">if</span> (dp[k] == MAX)</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 2294 | 동전 2&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="DP" scheme="https://whyz-dev.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 1451 | 직사각형으로 나누기</title>
    <link href="https://whyz-dev.github.io/2019/07/26/BOJ-1451-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EC%9C%BC%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0/"/>
    <id>https://whyz-dev.github.io/2019/07/26/BOJ-1451-직사각형으로-나누기/</id>
    <published>2019-07-26T09:54:32.000Z</published>
    <updated>2022-08-13T19:17:40.274Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/1451">https://www.acmicpc.net/problem/1451</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p><img src="/%5C01.png" alt="01"></p><p>가능한 6가지 경우의 수를 생각하여 모든 경우의 수를 계산해주면 된다.</p><p>직사각형의 넓이를 구할때는 구간 합(prefix sum)을 이용하여 O(1)에 계산해줄 수 있다.</p><p>두 직사각형 사이에 한 직사각형이 껴있는 경우의 시간복잡도는 각각 O(N^2)과 O(M^2),</p><p>나머지 경우의 수는 시간복잡도가 O(NM)이므로, 대충 전체 시간복잡도는 O(NM).</p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> N, M, arr[<span class="number">111</span>][<span class="number">111</span>], sum[<span class="number">111</span>][<span class="number">111</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>, &amp;arr[i][j]);</span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b, c;</span><br><span class="line">a = sum[i][j];</span><br><span class="line">b = sum[N][j] - sum[i][j];</span><br><span class="line">c = sum[N][M] - sum[N][j];</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a*b*c);</span><br><span class="line"></span><br><span class="line">b = sum[i][M] - sum[i][j];</span><br><span class="line">c = sum[N][M] - sum[i][M];</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a*b*c);</span><br><span class="line"></span><br><span class="line">a = sum[N][M] - sum[N][j] - sum[i][M] +sum[i][j];</span><br><span class="line">b = sum[N][j];</span><br><span class="line">c = sum[i][M] - sum[i][j];</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a*b*c);</span><br><span class="line"></span><br><span class="line">b = sum[i][M];</span><br><span class="line">c = sum[N][j] - sum[i][j];</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a*b*c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sum[i][M] * (sum[j][M] - sum[i][M]) *(sum[N][M] - sum[j][M]));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; M; j++)</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sum[N][i] * (sum[N][j] - sum[N][i]) *(sum[N][M] - sum[N][j]));</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 1451 | 직사각형으로 나누기&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="brute-force" scheme="https://whyz-dev.github.io/tags/brute-force/"/>
    
      <category term="prefix-sum" scheme="https://whyz-dev.github.io/tags/prefix-sum/"/>
    
  </entry>
  
  <entry>
    <title>[BOJ] 2293 | 동전 1</title>
    <link href="https://whyz-dev.github.io/2019/07/26/BOJ-2293-%EB%8F%99%EC%A0%84-1/"/>
    <id>https://whyz-dev.github.io/2019/07/26/BOJ-2293-동전-1/</id>
    <published>2019-07-26T07:38:33.000Z</published>
    <updated>2022-08-13T19:17:26.298Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="https://www.acmicpc.net/problem/2293">https://www.acmicpc.net/problem/2293</a></p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>DP를 사용하여 풀 수 있는 간단한 문제.</p><p>DP[i] &#x3D; 가격이 i일때 만들 수 있는 모든 경우의 수</p><p>DP[i] +&#x3D; DP[ i - coin[j] ], (j &#x3D; 0~n-1)</p><p>따라서 전체 시간복잡도는 O(nk)가 된다.</p><p>DP의 점화식을 2차원으로 세우면 메모리 초과가 나므로, 위와같은 1차원으로 짜주어야 한다.</p><p>for문을 돌 때, 가격이 i일때 경우의수를 0~n-1까지 도는 것이 아니라,</p><p> 물건 번호가 j일때 가격을 1~k까지 DP를 업데이트 하는것에 주의하자.</p><h2 id="소스"><a href="#소스" class="headerlink" title="소스"></a>소스</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, dp[<span class="number">10010</span>], coin[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">cin &gt;&gt; coin[i];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(coin, coin + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line"><span class="keyword">if</span> (i &gt;= coin[j])</span><br><span class="line">dp[i] += dp[i - coin[j]];</span><br><span class="line">cout &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[BOJ] 2293 | 동전 1&lt;/p&gt;
    
    </summary>
    
      <category term="PS" scheme="https://whyz-dev.github.io/categories/PS/"/>
    
    
      <category term="BOJ" scheme="https://whyz-dev.github.io/tags/BOJ/"/>
    
      <category term="DP" scheme="https://whyz-dev.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Intro</title>
    <link href="https://whyz-dev.github.io/2019/07/21/%EC%9D%B4-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/"/>
    <id>https://whyz-dev.github.io/2019/07/21/이-블로그에-대하여/</id>
    <published>2019-07-21T12:10:33.000Z</published>
    <updated>2022-08-13T19:20:36.269Z</updated>
    
    <content type="html"><![CDATA[<p>안녕하세요, 0rkha입니다.</p><p>오늘 2019&#x2F;07&#x2F;21을 기준으로 새로운 깃허브 블로그를 개설하게 되었습니다.</p><span id="more"></span><p>아마 머신러닝과 딥러닝, 알고리즘 등의 데이터 사이언스 부분의 포스팅을 주로 하게 될것 같습니다.</p><p>블로그의 테마는  <a href="https://github.com/LouisBarranqueiro">LouisBarranqueiro</a>의 <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">tranquilpeak</a>를 이용하여 수정하였습니다.</p><p>게시글에 대하여 궁금한 점이나 개인적으로 연락하시고 싶으시면,</p><p><a href="mailto:&#x34;&#x75;&#114;&#97;&#48;&#50;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x34;&#x75;&#114;&#97;&#48;&#50;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;</a> 으로 메일을 보내주시면 감사하겠습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;안녕하세요, 0rkha입니다.&lt;/p&gt;
&lt;p&gt;오늘 2019&amp;#x2F;07&amp;#x2F;21을 기준으로 새로운 깃허브 블로그를 개설하게 되었습니다.&lt;/p&gt;
    
    </summary>
    
    
      <category term="etc" scheme="https://whyz-dev.github.io/tags/etc/"/>
    
  </entry>
  
</feed>
