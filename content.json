{"meta":{"title":"whyz Blog","subtitle":null,"description":null,"author":"whyz (GangJun Jo)","url":"https://whyz-dev.github.io"},"pages":[{"title":"BLOGS","date":"2019-07-28T03:10:34.000Z","updated":"2019-07-28T03:10:34.662Z","comments":true,"path":"BLOGS/index.html","permalink":"https://whyz-dev.github.io/BLOGS/index.html","excerpt":"","text":""},{"title":"All-Archives","date":"2022-04-15T12:22:52.997Z","updated":"2019-07-25T14:32:13.501Z","comments":false,"path":"all-archives/index.html","permalink":"https://whyz-dev.github.io/all-archives/index.html","excerpt":"","text":""},{"title":"All-Categories","date":"2020-11-16T01:58:53.439Z","updated":"2019-07-21T10:32:26.556Z","comments":false,"path":"all-categories/index.html","permalink":"https://whyz-dev.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"All-Tags","date":"2020-11-16T01:58:53.446Z","updated":"2019-07-21T11:10:10.326Z","comments":false,"path":"all-tags/index.html","permalink":"https://whyz-dev.github.io/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Dacon] 2024 생명연구자원 AI활용 경진대회 후기","slug":"Dacon-2024-생명연구자원-AI활용-경진대회-후기","date":"2024-10-31T08:37:48.000Z","updated":"2024-10-31T09:56:12.395Z","comments":true,"path":"2024/10/31/Dacon-2024-생명연구자원-AI활용-경진대회-후기/","link":"","permalink":"https://whyz-dev.github.io/2024/10/31/Dacon-2024-%EC%83%9D%EB%AA%85%EC%97%B0%EA%B5%AC%EC%9E%90%EC%9B%90-AI%ED%99%9C%EC%9A%A9-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C-%ED%9B%84%EA%B8%B0/","excerpt":"[Dacon] 2024 생명연구자원 AI활용 경진대회 후기","text":"후기 몇 달 전에 정형 데이터 머신러닝을 공부하기 위해서 캐글에 있는 Housing Prices Competition for Kaggle Learn Users라는 모의 대회를 참여했었다. 마침 공부하기에 좋은 코드가 있었고, 이를 적용해볼만한 정형 데이터 대회가 없을까 하다가 발견한 대회가 Dacon의 2024 생명연구자원 AI활용 경진대회였다. 데이터를 처음 봤을 때 이게 무슨 의미인지 한참 고민했다. 알 수 없는 용어들과 무수한 WT들.. 덕분에 몇 일 동안은 chatGPT를 끼고 도메인 지식을 얻으려고 애썼다. 나는 각 열의 이름이 유전자의 이름을 나타낸다는 것과 WT를 제외한 데이터는 SNV 형태의 데이터를 의미한다는 것을 알았다. 변이의 종류(Silent, Missense, Nonsense)로 one-hot encoding하고 이를 단순하게 XGBoost에 넣어 Baseline을 만들었다. 이 대회의 평가 산식은 F1 score macro였다. 그리고 초기에 제출했던 내 퍼블릭 스코어는 0.119이다. 그 당시 상위권의 스코어가 0.6~0.7이었으니 이정도 상승을 노리려면 모델을 깎기보다 데이터를 더 다듬어 보기로했다. 먼저 나는 대회에서 제공하는 데이터가 부족하다는 것을 느꼈다. 그래서 TCGA가 제공하는 MAF 파일을 대회의 입력에 맞게 전처리를 했다. 그리고 변이의 종류에 따라서 암에 주는 영향이 다르다는 도메인 지식을 이용해 암에 더 영향을 많이줄수록 더 많은 점수를 주도록 label encoding을 진행하였다. 또한 모델의 입력 크기가 4300정도였으니 이는 모델에 차원의 저주가 있을 수 있다고 생각했고 PCA를 적용하였다. 이후 스코어는 0.386으로 상승했다. 이외에도 대회에서 분류하는 데 사용하지 않는 예측 변수 데이터를 other로 분리하여 학습하는데 사용해보았다. 그리고 LightGBM, MLP과 같은 다른 모델을 적용하거나 voting classifier로 ensemble도 해보았으나 정답률 향상이 크지 않았다. 따라서 나는 여전히 데이터에서 개선할 부분이 있을 것이라고 생각했고, 예측 class의 불균형 문제를 해결하지 않았음을 깨닫고 SMOTE와 ADASYN을 이용하여 클래스 불균형 문제를 해결했다. 그러면서 스코어는 0.45까지 상승했다. 이후 나는 데이터를 ICGC와 GTEX 데이터를 추가해보았으나 정답률에 큰 영향이 없음을 알았고, 이제 데이터가 부족한 것은 아니며 모델을 깎을 수도 없으므로 피쳐를 해석하는 부분에서 정답률 개선을 이루어야겠다고 생각했다. 단순 변이 종류를 레이블 인코딩한 것 이외에, 한 유전자에서 일어나는 변이의 개수와 점수의 합, 변이 위치의 최솟값 등을 이용해 스코어를 0.49까지 상승시켰다. 그리고 나서 한동안 진전이 없었으므로 도메인 지식과 관련된 정보를 다시 공부하고자했다. 때문에 나는 “Misannotated Multi-Nucleotide Variants in Public CancerGenomics Datasets Lead to Inaccurate Mutation Callswith Significant Implications” 이라는 논문과 “Cancer classification based on multiple dimensions: SNV patterns”를 읽었다. 간단히 요약하면 SNV 데이터는 하나의 아미노산 변이만을 표기하므로 여러개의 변이를 포함하는 MNV 데이터로 변환하면 정답률이 올라갈것이라는 것과, 아미노산이 변이하기 전과 후의 정보로 KNN 클러스터링을 하면 암 종류 분석의 정답률이 높게 나온다는 논문이었다. 나는 이를 이용하여 새로운 피쳐를 추가하였고 0.502의 스코어를 얻었다. 이를 마지막 제출로 나는 최종 17등을 할 수 있었다. 비율로 따지면 상위 **1.8%**의 성적이다. 2년만에 나가본 대회인데, 2년 전이랑은 비교도 안되는 순위로 마무리를 할 수 있었다는 것에 크게 만족하고있다. Kaggle에서 Expert를 달자는 목표에 한 발자국 다가갈 수 있어서 정말 기쁘다. 앞으로도 더 좋은 성적을 거둘 수 있도록 연습을 꾸준히 해야겠다.","categories":[{"name":"Dacon","slug":"Dacon","permalink":"https://whyz-dev.github.io/categories/Dacon/"}],"tags":[{"name":"review","slug":"review","permalink":"https://whyz-dev.github.io/tags/review/"},{"name":"structured data","slug":"structured-data","permalink":"https://whyz-dev.github.io/tags/structured-data/"},{"name":"bio data","slug":"bio-data","permalink":"https://whyz-dev.github.io/tags/bio-data/"},{"name":"ML","slug":"ML","permalink":"https://whyz-dev.github.io/tags/ML/"}],"keywords":[{"name":"Dacon","slug":"Dacon","permalink":"https://whyz-dev.github.io/categories/Dacon/"}]},{"title":"[BOJ] 3176 | 도로 네트워크","slug":"BOJ-3176-도로-네트워크","date":"2019-08-07T14:06:00.000Z","updated":"2022-08-13T19:17:17.398Z","comments":true,"path":"2019/08/07/BOJ-3176-도로-네트워크/","link":"","permalink":"https://whyz-dev.github.io/2019/08/07/BOJ-3176-%EB%8F%84%EB%A1%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/","excerpt":"[BOJ] 3176 | 도로 네트워크","text":"문제https://www.acmicpc.net/problem/3176 풀이sparse table을 이용한 LCA 문제. LCA를 구현하고, 다음과 같은 DP 테이블을 만든다. maxi[i][j] &#x3D; i의 j번째 조상까지의 도로중 가장 긴 도로의 길이. maxi[i][j] &#x3D; max(maxi[parent[i][j - 1]][j - 1], maxi[i][j-1]); maxi[i][j] &#x3D; i의 j번째 조상까지의 도로중 가장 짧은 도로의 길이. mini[i][j] &#x3D; min(mini[parent[i][j - 1]][j - 1], mini[i][j - 1]); 이를 잘 이용하여 풀면 된다. sparse-table 초기화에 O(NlogN) 쿼리 실행 중, 두 노드의 높이를 맞추는데 O(logN), 가장 긴&#x2F;짧은 도로를 찾는데 O(logN)이므로, 쿼리 실행의 시간복잡도는 O(QlogN). 전체 시간복잡도는 O((Q+N)logN) 소스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define P pair&lt;int,int&gt;using namespace std;int n, q, depth[110000], mini[110000][20], maxi[110000][20], parent[110000][20];vector&lt;P&gt; G[110000];queue&lt;int&gt; Q;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; G[a].push_back(&#123; b,c &#125;); G[b].push_back(&#123; a,c &#125;); &#125; depth[1] = 1; parent[1][0] = 1; Q.push(1); while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (P nxt : G[now]) &#123; if (!depth[nxt.first]) &#123; depth[nxt.first] = depth[now] + 1; mini[nxt.first][0] = nxt.second; maxi[nxt.first][0] = nxt.second; parent[nxt.first][0] = now; Q.push(nxt.first); &#125; &#125; &#125; for (int i = 1; i &lt; 20; i++) for (int j = 1; j &lt;= n; j++) &#123; parent[j][i] = parent[parent[j][i - 1]][i - 1]; maxi[j][i] = max(maxi[parent[j][i - 1]][i - 1], maxi[j][i-1]); mini[j][i] = min(mini[parent[j][i - 1]][i - 1], mini[j][i - 1]); &#125; cin &gt;&gt; q; while (q--) &#123; int a, b, dismax=0, dismin=1000000; cin &gt;&gt; a &gt;&gt; b; if (depth[a] &lt; depth[b]) swap(a, b); int diff = depth[a] - depth[b]; for(int i=0; diff; i++) &#123; if (diff &amp; 1) &#123; dismax = max(dismax, maxi[a][i]); dismin = min(dismin, mini[a][i]); a = parent[a][i]; &#125; diff /= 2; &#125; if (a != b) &#123; for (int i = 19; i &gt;= 0; i--) &#123; if (parent[a][i] != parent[b][i]) &#123; dismax = max(&#123; dismax, maxi[a][i], maxi[b][i] &#125;); dismin = min(&#123; dismin, mini[a][i], mini[b][i] &#125;); a = parent[a][i], b = parent[b][i]; &#125; &#125; dismax = max(&#123; dismax, maxi[a][0], maxi[b][0] &#125;); dismin = min(&#123; dismin, mini[a][0], mini[b][0] &#125;); &#125; cout &lt;&lt; dismin &lt;&lt; &quot; &quot; &lt;&lt; dismax &lt;&lt; &quot;\\n&quot;; &#125;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"https://whyz-dev.github.io/tags/DP/"},{"name":"LCA","slug":"LCA","permalink":"https://whyz-dev.github.io/tags/LCA/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 5419 | 북서풍","slug":"BOJ-5419-북서풍","date":"2019-08-07T13:01:09.000Z","updated":"2022-08-13T19:17:15.706Z","comments":true,"path":"2019/08/07/BOJ-5419-북서풍/","link":"","permalink":"https://whyz-dev.github.io/2019/08/07/BOJ-5419-%EB%B6%81%EC%84%9C%ED%92%8D/","excerpt":"[BOJ] 5419 | 북서풍","text":"문제https://www.acmicpc.net/problem/5419 풀이임의의 한 섬(a,b)을 기준으로, 그 점과 이어질 수 있는 섬(c,d)들은 모두 a&lt;&#x3D;c와 b&gt;c를 만족해야한다. 이를 이용하여, y축을 기준으로 오름차순으로 정렬하고, y축이 같은 경우는 x기준으로 내림차순으로 정렬하면, 아무 섬이나 잡아도, 해당 섬 이전에 선택된 섬들은 모두 해당 섬보다 남쪽에 있을 것임이 자명하다.또한 이전에 선택된 섬들 중에, 해당 섬보다 동쪽에 있는 섬들의 개수를 세주면, 해당 섬보다 남쪽에 있으면서 동쪽에 있는 섬들을 모두 선택할 수 있게 된다. 단, 좌표가 -10^9~10^9이므로, O(N)으로 가능한 X좌표들을 모두 저장해두고, 이분 탐색으로 index 위치를 찾는다. 섬들의 개수는 세그먼트 트리로 O(logN)만에 구할 수 있으며, 개수 업데이트에 O(logN), 이분 탐색에 O(logN)이므로, 모든 점 탐색은O(NlogN)만에 가능하다. 소스12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#define P pair&lt;int,int&gt;using namespace std;int tree[400000], num[80000], MAX, T,N;bool cmp1(P a, P b) &#123; return a.first &lt; b.first; &#125;bool cmp2(P a, P b) &#123; return (a.second == b.second) ? (a.first &gt; b.first):(a.second &lt; b.second); &#125;void update(int p, int v) &#123; p += MAX; tree[p] += v; for (; p /= 2; tree[p] = tree[2 * p] + tree[2 * p + 1]);&#125;int sum(int s, int e) &#123; int res = 0; s += MAX, e += MAX; while (s &lt; e) &#123; if (s % 2) res += tree[s++]; if (e % 2 == 0) res += tree[e--]; s /= 2, e /= 2; &#125; if (e == s) res += tree[s]; return res;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; T;; while (T--) &#123; long long size = 0, res=0; vector&lt;P&gt; V; cin &gt;&gt; N; for (MAX = 1; MAX &lt; N; MAX *= 2); memset(tree, 0, sizeof(tree)); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; N; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; V.push_back(&#123; x,y &#125;); &#125; sort(V.begin(), V.end(), cmp1); for (int i = 0; i &lt; V.size(); i++) &#123; if (!i || num[size] != V[i].first) num[size++] = V[i].first; &#125; sort(V.begin(), V.end(), cmp2); for (P idx : V) &#123; int l = 0, r = size-1; while (l &lt; r) &#123; int m = (l + r) / 2; if (num[m] &gt; idx.first) r = m - 1; else if (num[m] &lt; idx.first) l = m + 1; else &#123; l = m; break; &#125; &#125; res += sum(l, size); update(l, 1); &#125; cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; &#125;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"segment-tree","slug":"segment-tree","permalink":"https://whyz-dev.github.io/tags/segment-tree/"},{"name":"binary-search","slug":"binary-search","permalink":"https://whyz-dev.github.io/tags/binary-search/"},{"name":"line-sweeping","slug":"line-sweeping","permalink":"https://whyz-dev.github.io/tags/line-sweeping/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 13537 | 수열과 쿼리 1","slug":"BOJ-13537-수열과-쿼리-1","date":"2019-08-01T14:04:48.000Z","updated":"2024-10-31T09:55:25.213Z","comments":true,"path":"2019/08/01/BOJ-13537-수열과-쿼리-1/","link":"","permalink":"https://whyz-dev.github.io/2019/08/01/BOJ-13537-%EC%88%98%EC%97%B4%EA%B3%BC-%EC%BF%BC%EB%A6%AC-1/","excerpt":"[BOJ] 13537 | 수열과 쿼리 1","text":"문제https://www.acmicpc.net/problem/13537 풀이수열을 다음과 같은 업데이트 쿼리로 해석한다. a b : 위치가 a인 위치를 b로 교체 그리고 쿼리 (i j k)를 k에 대해 내림차순으로 정렬한다. 업데이트 쿼리들도 마찬가지로, b에 대해 내림차순으로 정렬한다. 그리고, k&gt;b를 만족할때, 세그먼트 트리에서 위치가 a인 곳에 1을 업데이트 한다. 그러면, 트리에서 i부터 j까지의 합이 쿼리 (i j k)에 대한 답변이 된다. 출력할때도, 쿼리의 입력순으로 정렬해주자. 소스12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;#define ll long longusing namespace std;struct _ &#123; ll idx, i, j, k; &#125;;bool operator&lt;(_ a, _ b) &#123; return a.k &gt; b.k; &#125;vector&lt;_&gt; query;vector&lt;pair&lt;ll, ll&gt; &gt;arr, ans;ll N, MAX, tree[400000], M;void update(ll p, ll v) &#123; p += MAX; tree[p] = v; for (; p /= 2; tree[p] = tree[2 * p] + tree[2 * p + 1]);&#125;ll sum(ll s, ll e) &#123; ll res = 0; s += MAX, e += MAX; while (s &lt; e) &#123; if (s % 2) res += tree[s++]; if (e % 2 == 0) res += tree[e--]; e /= 2; s /= 2; &#125; if(s==e) res += tree[e]; return res;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; N; for (MAX = 1; MAX &lt; N; MAX *= 2); for (int i = 1; i &lt;= N; i++) &#123; ll tmp; cin &gt;&gt; tmp; arr.push_back(&#123; tmp,i &#125;); &#125; cin &gt;&gt; M; for (int i = 0; i &lt; M; i++) &#123; ll a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; query.push_back(&#123; i,a,b,c &#125;); &#125; sort(arr.begin(), arr.end(), greater&lt;pair&lt;ll, ll&gt; &gt;() ); sort(query.begin(), query.end()); ll now = 0; for (auto idx : query) &#123; while (now &lt; arr.size() &amp;&amp; idx.k &lt; arr[now].first) &#123; update(arr[now].second, 1); now++; &#125; ans.push_back(&#123; idx.idx, sum(idx.i,idx.j) &#125;); &#125; sort(ans.begin(), ans.end()); for (auto idx : ans) cout &lt;&lt; idx.second &lt;&lt; &quot;\\n&quot;;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"segment_tree","slug":"segment-tree","permalink":"https://whyz-dev.github.io/tags/segment-tree/"},{"name":"sort","slug":"sort","permalink":"https://whyz-dev.github.io/tags/sort/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 2436 | 공약수","slug":"BOJ-2436-공약수","date":"2019-07-28T03:10:00.000Z","updated":"2022-08-13T19:17:19.810Z","comments":true,"path":"2019/07/28/BOJ-2436-공약수/","link":"","permalink":"https://whyz-dev.github.io/2019/07/28/BOJ-2436-%EA%B3%B5%EC%95%BD%EC%88%98/","excerpt":"[BOJ] 2436 | 공약수","text":"문제https://www.acmicpc.net/problem/2436 출처 KOI 2011 초등부 2번 KOI 2011 중등부 1번 KOI 2011 고등부 1번 풀이유클리드 호제법 (최대공약수 구하기) :https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95 여기서는 두 입력으로 최대공약수와 최소공배수를 준다. 두 수를 각 a와 b라고 할때, LCM을 다음과 같이 나타낼 수 있다. LCM &#x3D; a*b&#x2F;GCD 이를 정리하면, GCD * LCM &#x3D; a*b 이를 이용하여 시간복잡도 O(sqrt(GCD*LCM)) &#x3D; O(sqrt(a*b))만에 풀 수 있다. 입력이 1억이니, int 범위 초과에 주의하자. 소스123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;long long GCD, LCM, mul, a, b, flag;long long gcd(long long a, long long b) &#123; return b ? gcd(b, a%b) : a;&#125;int main() &#123; cin &gt;&gt; GCD &gt;&gt; LCM; mul = GCD * LCM; a = 1; b = LCM; for (int i = 1; i &lt;= mul / i; i++) &#123; if (mul%i || gcd(i, mul / i) != GCD) continue; flag = 1; a = i, b = mul / i; &#125; if(flag) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"KOI","slug":"KOI","permalink":"https://whyz-dev.github.io/tags/KOI/"},{"name":"Euclidean-algorithm","slug":"Euclidean-algorithm","permalink":"https://whyz-dev.github.io/tags/Euclidean-algorithm/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 11047 | 동전 0","slug":"BOJ-11047-동전-0","date":"2019-07-26T13:55:16.000Z","updated":"2022-08-13T19:17:13.484Z","comments":true,"path":"2019/07/26/BOJ-11047-동전-0/","link":"","permalink":"https://whyz-dev.github.io/2019/07/26/BOJ-11047-%EB%8F%99%EC%A0%84-0/","excerpt":"[BOJ] 11047 | 동전 0","text":"문제https://www.acmicpc.net/problem/11047 풀이문제를 읽어보면, “A_1 &#x3D; 1, i ≥ 2인 경우에 A_i는 A_{i-1}의 배수”라는 조건이 있는데, 첫번째 조건을 통해, “만들지 못하는 경우는 없다.”를 추측해낼 수 있고, 두번째 조건을 통해, “tA_{i-1}는 A_i로 대체할 수 있다.”를 추측해낼 수 있다. (t는 임의의 상수) 가치가 A_i인 동전을 가치가 A_{i-1}동전으로 대체할 수 있으나, 가치가 A_{i-1}를 여러개 쓰는 것 보다, 가치가 A_i인 큰 동전 하나로 바꾸는게 이득이라는 것을 알 수 있다. 이렇게 가장 큰 동전부터 사용하여, greedy한 방법으로 정답을 찾을 수 있다. 시간복잡도는 동전의 개수, 즉 O(N)이다. 소스12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int n, k, cnt, coin[11];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;=n; i++) cin &gt;&gt; coin[i]; while (n) &#123; if (coin[n] &gt; k) &#123; n--; continue; &#125; cnt += k / coin[n]; k %= coin[n]; &#125; cout &lt;&lt; cnt;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"greedy","slug":"greedy","permalink":"https://whyz-dev.github.io/tags/greedy/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 2294 | 동전 2","slug":"BOJ-2294-동전-2","date":"2019-07-26T13:32:25.000Z","updated":"2022-08-13T19:17:21.618Z","comments":true,"path":"2019/07/26/BOJ-2294-동전-2/","link":"","permalink":"https://whyz-dev.github.io/2019/07/26/BOJ-2294-%EB%8F%99%EC%A0%84-2/","excerpt":"[BOJ] 2294 | 동전 2","text":"문제https://www.acmicpc.net/problem/2294 풀이https://www.acmicpc.net/problem/2293을 풀면 사고를 확장하여 쉽게 풀 수 있다. DP[i]를 i번 동전을 만들 수 있는 최소 횟수라고 정의하면, DP[i] &#x3D; max(DP[i], DP[ i - coin[j] ] + 1), j &#x3D; 0~n-1 로 정리된다. 위 점화식을 그대로 적용하면 AC를 받게된다. 시간복잡도는 동전 1과 같은 O(NM). 소스1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 10000001using namespace std;int n, k, dp[10010], coin[101];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt;n; i++) cin &gt;&gt; coin[i]; for (int i = 1; i &lt;= k; i++) dp[i] = MAX; sort(coin, coin + n); for (int j = 0; j &lt; n; j++) for (int i = 1; i &lt;= k; i++) if (i &gt;= coin[j]) dp[i] = min(dp[i - coin[j]]+1, dp[i]); if (dp[k] == MAX) cout &lt;&lt; -1; else cout &lt;&lt; dp[k];&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"https://whyz-dev.github.io/tags/DP/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 1451 | 직사각형으로 나누기","slug":"BOJ-1451-직사각형으로-나누기","date":"2019-07-26T09:54:32.000Z","updated":"2022-08-13T19:17:40.274Z","comments":true,"path":"2019/07/26/BOJ-1451-직사각형으로-나누기/","link":"","permalink":"https://whyz-dev.github.io/2019/07/26/BOJ-1451-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95%EC%9C%BC%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0/","excerpt":"[BOJ] 1451 | 직사각형으로 나누기","text":"문제https://www.acmicpc.net/problem/1451 풀이 가능한 6가지 경우의 수를 생각하여 모든 경우의 수를 계산해주면 된다. 직사각형의 넓이를 구할때는 구간 합(prefix sum)을 이용하여 O(1)에 계산해줄 수 있다. 두 직사각형 사이에 한 직사각형이 껴있는 경우의 시간복잡도는 각각 O(N^2)과 O(M^2), 나머지 경우의 수는 시간복잡도가 O(NM)이므로, 대충 전체 시간복잡도는 O(NM). 소스123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;long long N, M, arr[111][111], sum[111][111], ans;int main() &#123; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); for (int i = 1; i &lt;= N; i++) for (int j = 1; j &lt;= M; j++) &#123; scanf(&quot;%1d&quot;, &amp;arr[i][j]); sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + arr[i][j]; &#125; for (int i = 1; i &lt; N; i++) for (int j = 1; j &lt; M; j++) &#123; long long a, b, c; a = sum[i][j]; b = sum[N][j] - sum[i][j]; c = sum[N][M] - sum[N][j]; ans = max(ans, a*b*c); b = sum[i][M] - sum[i][j]; c = sum[N][M] - sum[i][M]; ans = max(ans, a*b*c); a = sum[N][M] - sum[N][j] - sum[i][M] +sum[i][j]; b = sum[N][j]; c = sum[i][M] - sum[i][j]; ans = max(ans, a*b*c); b = sum[i][M]; c = sum[N][j] - sum[i][j]; ans = max(ans, a*b*c); &#125; for (int i = 1; i &lt; N; i++) for (int j = i + 1; j &lt; N; j++) ans = max(ans, sum[i][M] * (sum[j][M] - sum[i][M]) *(sum[N][M] - sum[j][M])); for (int i = 1; i &lt; M; i++) for (int j = i + 1; j &lt; M; j++) ans = max(ans, sum[N][i] * (sum[N][j] - sum[N][i]) *(sum[N][M] - sum[N][j])); cout &lt;&lt; ans;&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"brute-force","slug":"brute-force","permalink":"https://whyz-dev.github.io/tags/brute-force/"},{"name":"prefix-sum","slug":"prefix-sum","permalink":"https://whyz-dev.github.io/tags/prefix-sum/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"[BOJ] 2293 | 동전 1","slug":"BOJ-2293-동전-1","date":"2019-07-26T07:38:33.000Z","updated":"2022-08-13T19:17:26.298Z","comments":true,"path":"2019/07/26/BOJ-2293-동전-1/","link":"","permalink":"https://whyz-dev.github.io/2019/07/26/BOJ-2293-%EB%8F%99%EC%A0%84-1/","excerpt":"[BOJ] 2293 | 동전 1","text":"문제https://www.acmicpc.net/problem/2293 풀이DP를 사용하여 풀 수 있는 간단한 문제. DP[i] &#x3D; 가격이 i일때 만들 수 있는 모든 경우의 수 DP[i] +&#x3D; DP[ i - coin[j] ], (j &#x3D; 0~n-1) 따라서 전체 시간복잡도는 O(nk)가 된다. DP의 점화식을 2차원으로 세우면 메모리 초과가 나므로, 위와같은 1차원으로 짜주어야 한다. for문을 돌 때, 가격이 i일때 경우의수를 0~n-1까지 도는 것이 아니라, 물건 번호가 j일때 가격을 1~k까지 DP를 업데이트 하는것에 주의하자. 소스123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, k, dp[10010], coin[101];int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt;n; i++) cin &gt;&gt; coin[i]; dp[0] = 1; sort(coin, coin + n); for (int j = 0; j &lt; n; j++) for (int i = 1; i &lt;= k; i++) if (i &gt;= coin[j]) dp[i] += dp[i - coin[j]]; cout &lt;&lt; dp[k];&#125;","categories":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://whyz-dev.github.io/tags/BOJ/"},{"name":"DP","slug":"DP","permalink":"https://whyz-dev.github.io/tags/DP/"}],"keywords":[{"name":"PS","slug":"PS","permalink":"https://whyz-dev.github.io/categories/PS/"}]},{"title":"Intro","slug":"이-블로그에-대하여","date":"2019-07-21T12:10:33.000Z","updated":"2022-08-13T19:20:36.269Z","comments":true,"path":"2019/07/21/이-블로그에-대하여/","link":"","permalink":"https://whyz-dev.github.io/2019/07/21/%EC%9D%B4-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/","excerpt":"안녕하세요, 0rkha입니다. 오늘 2019&#x2F;07&#x2F;21을 기준으로 새로운 깃허브 블로그를 개설하게 되었습니다.","text":"안녕하세요, 0rkha입니다. 오늘 2019&#x2F;07&#x2F;21을 기준으로 새로운 깃허브 블로그를 개설하게 되었습니다. 아마 머신러닝과 딥러닝, 알고리즘 등의 데이터 사이언스 부분의 포스팅을 주로 하게 될것 같습니다. 블로그의 테마는 LouisBarranqueiro의 tranquilpeak를 이용하여 수정하였습니다. 게시글에 대하여 궁금한 점이나 개인적으로 연락하시고 싶으시면, &#52;&#117;&#x72;&#x61;&#x30;&#x32;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109; 으로 메일을 보내주시면 감사하겠습니다.","categories":[],"tags":[{"name":"etc","slug":"etc","permalink":"https://whyz-dev.github.io/tags/etc/"}],"keywords":[]}]}